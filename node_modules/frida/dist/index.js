"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const deviceManagerModule = require("./device_manager");
const deviceModule = require("./device");
const scriptModule = require("./script");
const sessionModule = require("./session");
const bindings = require("bindings");
exports.DeviceManager = deviceManagerModule.DeviceManager;
exports.Device = deviceModule.Device;
exports.DeviceType = deviceModule.DeviceType;
exports.Session = sessionModule.Session;
exports.SessionDetachReason = sessionModule.SessionDetachReason;
exports.Script = scriptModule.Script;
exports.ScriptRuntime = scriptModule.ScriptRuntime;
exports.MessageType = scriptModule.MessageType;
exports.LogLevel = scriptModule.LogLevel;
const binding = bindings({
    bindings: "frida_binding",
    try: [
        ["module_root", "build", "bindings"],
        ["module_root", "build", "Debug", "bindings"],
        ["module_root", "build", "Release", "bindings"],
        ["module_root", "out", "Debug", "bindings"],
        ["module_root", "Debug", "bindings"],
        ["module_root", "out", "Release", "bindings"],
        ["module_root", "Release", "bindings"],
        ["module_root", "build", "default", "bindings"],
        ["module_root", "compiled", "version", "platform", "arch", "bindings"],
        [process.cwd(), "bindings"],
    ]
});
let sharedDeviceManager = null;
async function spawn(program, options = {}) {
    const device = await getLocalDevice();
    return await device.spawn(program, options);
}
exports.spawn = spawn;
async function resume(target) {
    const device = await getLocalDevice();
    await device.resume(target);
}
exports.resume = resume;
async function kill(target) {
    const device = await getLocalDevice();
    await device.kill(target);
}
exports.kill = kill;
async function attach(target) {
    const device = await getLocalDevice();
    return await device.attach(target);
}
exports.attach = attach;
async function injectLibraryFile(target, path, entrypoint, data) {
    const device = await getLocalDevice();
    return await device.injectLibraryFile(target, path, entrypoint, data);
}
exports.injectLibraryFile = injectLibraryFile;
async function injectLibraryBlob(target, blob, entrypoint, data) {
    const device = await getLocalDevice();
    return await device.injectLibraryBlob(target, blob, entrypoint, data);
}
exports.injectLibraryBlob = injectLibraryBlob;
async function enumerateDevices() {
    const deviceManager = getDeviceManager();
    return await deviceManager.enumerateDevices();
}
exports.enumerateDevices = enumerateDevices;
;
function getDeviceManager() {
    if (sharedDeviceManager === null) {
        sharedDeviceManager = new deviceManagerModule.DeviceManager(new binding.DeviceManager());
    }
    return sharedDeviceManager;
}
exports.getDeviceManager = getDeviceManager;
function getLocalDevice() {
    return getMatchingDevice(device => device.type === exports.DeviceType.Local);
}
exports.getLocalDevice = getLocalDevice;
function getRemoteDevice() {
    return getMatchingDevice(device => device.type === exports.DeviceType.Remote);
}
exports.getRemoteDevice = getRemoteDevice;
function getUsbDevice(options) {
    return getMatchingDevice(device => device.type === exports.DeviceType.Usb, options);
}
exports.getUsbDevice = getUsbDevice;
function getDevice(id, options) {
    return getMatchingDevice(device => device.id === id, options);
}
exports.getDevice = getDevice;
async function getMatchingDevice(predicate, options = {}) {
    const device = await findMatchingDevice(predicate);
    if (device !== null) {
        return device;
    }
    const { timeout = 0 } = options;
    if (timeout === 0) {
        throw new Error("Device not found");
    }
    const getDeviceEventually = new Promise((resolve, reject) => {
        const deviceManager = getDeviceManager();
        deviceManager.added.connect(onDeviceAdded);
        const timer = (timeout !== null) ? setTimeout(onTimeout, timeout) : null;
        findMatchingDevice(predicate)
            .then(device => {
            if (device !== null) {
                onSuccess(device);
            }
        })
            .catch(onError);
        function onDeviceAdded(device) {
            if (predicate(device)) {
                onSuccess(device);
            }
        }
        function onSuccess(device) {
            stopMonitoring();
            resolve(device);
        }
        function onError(error) {
            stopMonitoring();
            reject(error);
        }
        function onTimeout() {
            onError(new Error("Timed out while waiting for device to appear"));
        }
        function stopMonitoring() {
            if (timer !== null) {
                clearTimeout(timer);
            }
            deviceManager.added.disconnect(onDeviceAdded);
        }
    });
    return await getDeviceEventually;
}
async function findMatchingDevice(predicate) {
    const deviceManager = getDeviceManager();
    const devices = await deviceManager.enumerateDevices();
    const matching = devices.filter(predicate);
    if (matching.length === 0) {
        return null;
    }
    return matching[0];
}
