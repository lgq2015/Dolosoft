"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const session_1 = require("./session");
const signals_1 = require("./signals");
const minimatch_1 = require("minimatch");
const util_1 = require("util");
class Device {
    constructor(impl) {
        this.impl = impl;
        const { signals } = impl;
        this.spawnAdded = new signals_1.Signal(signals, "spawn-added");
        this.spawnRemoved = new signals_1.Signal(signals, "spawn-removed");
        this.childAdded = new signals_1.Signal(signals, "child-added");
        this.childRemoved = new signals_1.Signal(signals, "child-removed");
        this.processCrashed = new signals_1.Signal(signals, "process-crashed");
        this.output = new signals_1.Signal(signals, "output");
        this.uninjected = new signals_1.Signal(signals, "uninjected");
        this.lost = new signals_1.Signal(signals, "lost");
    }
    get id() {
        return this.impl.id;
    }
    get name() {
        return this.impl.name;
    }
    get icon() {
        return this.impl.icon;
    }
    get type() {
        return this.impl.type;
    }
    getFrontmostApplication() {
        return this.impl.getFrontmostApplication();
    }
    enumerateApplications() {
        return this.impl.enumerateApplications();
    }
    enumerateProcesses() {
        return this.impl.enumerateProcesses();
    }
    async getProcess(name) {
        const processes = await this.enumerateProcesses();
        const mm = new minimatch_1.Minimatch(name.toLowerCase());
        const matching = processes.filter(process => mm.match(process.name.toLowerCase()));
        if (matching.length === 1) {
            return matching[0];
        }
        else if (matching.length > 1) {
            throw new Error("Ambiguous name; it matches: " + matching.map(process => `${process.name} (pid: ${process.pid})`).join(", "));
        }
        else {
            throw new Error("Process not found");
        }
    }
    enableSpawnGating() {
        return this.impl.enableSpawnGating();
    }
    disableSpawnGating() {
        return this.impl.disableSpawnGating();
    }
    enumeratePendingSpawn() {
        return this.impl.enumeratePendingSpawn();
    }
    enumeratePendingChildren() {
        return this.impl.enumeratePendingChildren();
    }
    spawn(program, options = {}) {
        const pendingOptions = Object.assign({}, options);
        let argv = consumeOption("argv");
        if (typeof program !== "string") {
            argv = program;
            program = argv[0];
            if (argv.length === 1) {
                argv = null;
            }
        }
        const envp = consumeOption("envp");
        const env = consumeOption("env");
        const cwd = consumeOption("cwd");
        const stdio = consumeOption("stdio");
        const aux = pendingOptions;
        return this.impl.spawn(program, argv, envp, env, cwd, stdio, aux);
        function consumeOption(name) {
            const value = pendingOptions[name];
            if (value === undefined) {
                return null;
            }
            delete pendingOptions[name];
            return value;
        }
    }
    async input(target, data) {
        return this.impl.input(await this.getPid(target), data);
    }
    async resume(target) {
        return this.impl.resume(await this.getPid(target));
    }
    async kill(target) {
        return this.impl.kill(await this.getPid(target));
    }
    async attach(target) {
        return new session_1.Session(await this.impl.attach(await this.getPid(target)));
    }
    async injectLibraryFile(target, path, entrypoint, data) {
        return this.impl.injectLibraryFile(await this.getPid(target), path, entrypoint, data);
    }
    async injectLibraryBlob(target, blob, entrypoint, data) {
        return this.impl.injectLibraryBlob(await this.getPid(target), blob, entrypoint, data);
    }
    async getPid(target) {
        if (typeof target === "number") {
            return target;
        }
        const process = await this.getProcess(target);
        return process.pid;
    }
    [util_1.inspect.custom](depth, options) {
        return "Device " + util_1.inspect({
            id: this.id,
            name: this.name,
            icon: this.icon,
            type: this.type
        }, options);
    }
}
exports.Device = Device;
var DeviceType;
(function (DeviceType) {
    DeviceType["Local"] = "local";
    DeviceType["Remote"] = "remote";
    DeviceType["Usb"] = "usb";
})(DeviceType = exports.DeviceType || (exports.DeviceType = {}));
var Stdio;
(function (Stdio) {
    Stdio["Inherit"] = "inherit";
    Stdio["Pipe"] = "pipe";
})(Stdio = exports.Stdio || (exports.Stdio = {}));
